PicoCTF:

### [Picker IV](https://play.picoctf.org/playlists/2?m=43)

This one is about using static code analysis to read from both a binary and a c file. 

I can see the win method at the top of the file. 
It will prompt me for the hex code value of where I want to jump to in the assembly code.

I assume this means that I can find the win method in the binary so we go to GDB !

```
Non-debugging symbols:
0x0000000000401000  _init
0x00000000004010e0  putchar@plt
0x00000000004010f0  puts@plt
0x0000000000401100  fclose@plt
0x0000000000401110  printf@plt
0x0000000000401120  fgetc@plt
0x0000000000401130  signal@plt
0x0000000000401140  setvbuf@plt
0x0000000000401150  fopen@plt
0x0000000000401160  __isoc99_scanf@plt
0x0000000000401170  exit@plt
0x0000000000401180  sleep@plt
0x0000000000401190  _start
0x00000000004011c0  _dl_relocate_static_pie
0x00000000004011d0  deregister_tm_clones
0x0000000000401200  register_tm_clones
0x0000000000401240  __do_global_dtors_aux
0x0000000000401270  frame_dummy
0x0000000000401276  print_segf_message
0x000000000040129e  win
0x0000000000401334  main
0x00000000004013d0  __libc_csu_init
0x0000000000401440  __libc_csu_fini
0x0000000000401448  _fini
```

Here are the functions that I can see and so I assume I just put in the win function to get the answer. Lets give it a shot!

My god, after the struggle I had with the python one, having a simple solution was so nice.
The flag was just

Apparently this is going to be important.
```bash
`$ python3 -c "import sys; sys.stdout.buffer.write('a'*36)"`
```
Typically fuzzing (trying a bunch of inputs) using a bunch of 'a' characters is common to try to abuse things.

It didn't produce anything for me but I get the concept. Its to get the desired amount of 'a'.

### [Local Target](https://play.picoctf.org/playlists/2?m=47)
"Smash the stack"
I assume Im gonna be popping a bunch of things off the stack but I have no real clue.

I am given a C file and it's assembly code and Ill have to grab the flag from that. 

First off, Ill see what the container looks like
```bash
Enter a string: test

num is 64
Bye!
```
And then it crashses? It doesnt take any more inputs now.
okay... I guess Ill have to read a bit...

```C
  char input[16];
  int num = 64;
  
  printf("Enter a string: ");
  fflush(stdout);
  gets(input);
  printf("\n");
  
  printf("num is %d\n", num);
  fflush(stdout);
  
  if( num == 65 ){
    printf("You win!\n");
    fflush(stdout);
```
So this is how we win. So I think that that means that I need to overflow the char[16] input to the point where it modifies the num variable.

