picoCTF:
##### [heap-1]()
Medium
Binary Exploitation
Desc: Can you control your overflow? Download the binary [here](https://artifacts.picoctf.net/c_tethys/3/chall). Download the source [here](https://artifacts.picoctf.net/c_tethys/3/chall.c).

Hypothesis: There is a buffer overflow and I will have to figure out how to abuse it to get to another flag.

There is a "safe" variable that I can fill by overflowing a variable I can write to and somehow this will reveal the flag to me.

I start by overflowing with the alphabet:
`abcdefghijklmnopqrstuvwxyz` // for reference and easy copying


![[heap-1.png]]

By passing in the alphabet twice I was able to see that a `ghi` is where the overflow would begin. I replaced the characters past the second `g` with `pico` and that printed out the flag for me.

##### [heap-2]()
Medium
Web Exploitation
Desc: Can you handle function pointers?

Hypothesis: Given a file binary, I will have to find the right pointer and possibly make a call to it.

```C
void check_win() { ((void (*)())*(int*)x)(); }
```
I need to be able to follow what exactly this is doing. It is calling the memory address of x as a function.

```C
void check_win() { (
(void (*)())  *(int*)x 
)(); }
```

I was using [[GDB]] to try and figure out what memory values I would care about but the writes ups that I have looked at are using `objdump -D`

I received the same output that I was looking for, I cared about the address of the win method, but I made the mistake when copying the address and dropping the last 0 so it was offset and wrong.

I found that the address of the win function was `0x00000000004011a0` so I wanted to pass that into the x value to try and print the flag. 
Originally I wasn't sure how to get it to work so I had tried doing some weird math to figure out where it was relative to the memory of the `x` that we saw when we printed the heap but that was not the goal.

I had the right inkling at the start but I did not know how to progress properly. I kept trying to manually type the address with all the `\x` in front of it but apparently it does not work manually.

Instead there is a way to write a simple python script that can input the solution for me, but I could not get it to work. I tried the following which was adapted from someone's python2 script. As I don't know the differences I could not properly translate it and instead I found that I could use `echo -e` and pipe it into the `nc` to make it submit for me.

The following are the scripts I used.

The following did not work for me:
`python3 -c "print('2'); print('pico'*8+'\xa0\x11\x40\x00'); print('4')" | nc mimas.picoctf.net 55743`
It clearly did something but I do not know what went wrong. I had no flag print out at the end.

The following worked:
`echo -e '2\nabcdefghijklmnopqrstuvwxyzabcdef\xa0\x11\x40\x00\n4\n' | nc mimas.picoctf.net 55743`


##### [heap-3](https://play.picoctf.org/practice/challenge/440?assigned=0&category=6&difficulty=2&page=1)
Medium
Binary Exploitation
This program mishandles memory. Can you exploit it to get the flag?
Hypothesis: I will have to find where the memory overflows and use it to print the flag

```c
// Create struct
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;
```

With this I think that my goal will be to overflow so that I point at the flag instead of the start of the struct.

`  if(!strcmp(x->flag, "pico")) {`
or because of this I will fill the flag[5] values with "pico" instead
To me that means writing 30 characters and then "pico" at the end.
